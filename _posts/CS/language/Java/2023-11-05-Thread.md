---
title:  "[Java] ☕ 멀티 쓰레드 (Multi Thread)"
excerpt: "JAVA CS 지식 관련 정리"
categories:
  - Java
tags:
  - [JUnit, CS, Java]

toc: true
toc_sticky: true
 
date: 2023-11-05
last_modified_at: 2023-11-05
---


## 📖 쓰레드

`멀티 쓰레드 프로그래밍`이란 하나의 응용 프로그램에서 동시에 여러 처리를 하기 위해 쓰레드를 생성하여 운영하는 프로그램이다.   
자바에서는 이를 지원하기 위하여 2가지 방법을 지원하는데, `Thread` 클래스를 상속받거나, `Runnable` 인터페이스를 구현하는 것이 있다.  

<br>

### 🍄 Thread 클래스

`Thread` 클래스 를 상속 받은 후, `run()` 함수를 오버라이딩 한다.  
이후, `run()` 메소드를 호출하면, `JVM`에서 새로운 쓰레드로 실행한다.  
따라서, 다른 클래스를 추가적으로 상속 받을 수 없기 때문에, 일반적으로 `Runnable` 인터페이스를 구현하여 스레드를 사용한다.  

```java
public class Main {

    public static void main(String[] args) {
        PrintOne thread1 = new PrintOne(1000);
        PrintOne thread2 = new PrintOne(1000);

        thread1.start();
        thread2.start();
    }
}

class PrintOne extends Thread{
    private int times;

    public PrintOne(int times){
        this.times = times;
    }

    @Override
    public void run(){
        for (int i = 0; i < times; i++) {
            System.out.println(1);
        }
    }
}
```

<div class="notice--warning" markdown="1">
`start()`와 `run()`의 차이

 - run()은 스레드 객체를 실행하는 것이 아닌, 클래스 내부의 run() 메소드를 실행시키는 것이다.
</div>

<br>

### 🍄 Runnable 인터페이스

`Runnable` interface를 구현하여 익명 구혁 객체나 구현 클래스로 구현하여 사용한다.  
다른 class의 상속을 받을 수 있기 때문에, 주로 쓰레드 사용시에는 `Runnable` 인터페이스를 사용한다.  

```java
public class Main {

    public static void main(String[] args) {
        Runnable printTwo = new PrintTwo(1000);
        
        Thread thread1 = new Thread(printTwo);
        Thread thread2 = new Thread(printTwo);

        thread1.start();
        thread2.start();
    }
}

class PrintOne implements Runnable{
    private int times;

    public PrintNum(int times){
        this.times = times;
    }

    @Override
    public void run(){
        for (int i = 0; i < times; i++) {
            System.out.println(2);
        }
    }
}
```

<br>

## 📖 쓰레드의 상태

- 객체 생성 (NEW) : start() 메소드가 호출되지 않은 상태로 스레드 객체를 생성.
- 실행 대기 (RUNNABLE) : 실행을 대기하는 상태, 언제든 실행 상태로 갈 수 있음.
- 일시 정지 (WAITING) : 다른 스레드가 통지할 때까지 기다리는 상태
- 일시 정지 (TIMED_WAITING) : 주어진 시간동안 기다리는 상태
- 일시 정지 (BLOCKED) : 동기화로 인해 사용하고자 하는 객체의 락이 풀릴 때까지 기다리는 상태  

이는 Thread 클래스의 getState() 메서드로 확인이 가능하다.  

![image](https://github.com/yyechan0602/yyechan0602.github.io/assets/37824506/0a2571d2-d91d-4d0a-a891-464567c93d62)


<br>

***
    개인 공부 기록용 블로그입니다.
    틀리거나 오류가 있을 경우 제보해주시면 감사하겠습니다.😁