---
title:  "[Algorithm] 📈 DFS(깊이 우선 탐색)와 BFS(넓이 우선 탐색)"
excerpt: "제한된 공간과 시간안에서 어떻게 데이터를 처리할지에 대한 알고리즘을 알아보자"
categories:
  - Type Of Algorithm
tags:
  - [DFS, BFS, Dynamic Programming, Algorithm, Algorithm1]

toc: true
toc_sticky: true
 
date: 2023-02-04
last_modified_at: 2023-02-04
---

## 📘 그래프를 탐색하는 방법

그래프란 노드와 간선으로 이루어진 자료구조의 일종이다.  
이 그래프를 탐색하는 방법에는 DFS(Depth-First Search) 즉, 깊이 우선 탐색 방법과 BFS(Breadth-First Search) 즉, 넓이 우선 탐색 방법이 있다.  
이때, 구현방법은 인접행렬과 인접리스트를 사용하여 구현하는데, 이에 대해 더 알아보고 싶으면 다음 링크를 살펴보길 바란다. 
 
<링크>

<br>

## 📖 DFS(깊이 우선 탐색)

다음은 `DFS`의 정의이다.  

그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘
{: .notice} 

`DFS`는 다음 그림과 같이 작동을 하며 일반적으로 `Stack`이나 재귀함수를 통해 구현한다.  

![img](https://user-images.githubusercontent.com/37824506/216763984-375437a2-9810-4581-8c31-36da050558dc.gif)
  출처:https://developer-mac.tistory.com/64  

 - 탐색 시작 노드를 `Stack`에 삽입하고 방문 처리한다.
 - `Stack`의 top에 있는 노드에 인접한 노드가 하나라도 있으면, 그 노드를 방문 처리하고, `Stack`에 넣는다.
 - 방문하지 않은 노드가 없으면 `Top`에서 노드를 꺼낸다.
 - 2와 3을 수행할 수 없을 떄까지 반복한다.

<br>

## 📖 구현

### 📋 재귀 호출  


```
static Stack<Integer> stack = new Stack<>();
static StringBuilder sb = new StringBuilder();
static boolean node[][] = new boolean[n+1][n+1], visited[] = new boolean[n+1];
static void dfs(int v) {
	if(visited[v])
    	return;
	sb.append(v+" ");
	for(int i=1; i<=n; i++)
		if(node[v][i] && !visited[i]) {
			visited[i] = true;
			dfs(i);
		}
}
```

<br>

### 📋 스택 사용  

```
public static String dfs(int v, boolean node[][]) {
    StringBuilder sb = new StringBuilder();
    Stack<Integer> stack = new Stack<>();
    boolean visited[] = new boolean[n+1];
    stack.add(v);
    int idx;
    while(!stack.isEmpty()) {
        idx = stack.pop();
        if(visited[idx])
            continue;
        visited[idx] = true;
        sb.append(idx+" ");
        for(int i=0; i<n; i++)
            if(node[idx][i] && !visited[i])
                stack.add(i);
    }
    return sb.toString();
}
```

<br>

## 📖 BFS(넓이 우선 탐색)

다음은 `BFS`의 정의이다.  

그래프에서 가까운 노드부터 우선적으로 탐색하는 알고리즘
{: .notice} 

`BFS`는 다음 그림과 같이 작동을 하며, 일반적으로 `Queue`를 사용하여 구현한다.  

![img](https://user-images.githubusercontent.com/37824506/216764000-80717e3e-5770-4903-8beb-b82b72448411.gif)
  출처:https://developer-mac.tistory.com/64  

 - 탐색 시작 노드를 `Queue`에 삽입하고 방문 처리한다.
 - `Queue`에서 노드를 꺼낸후 인접 노드중 방문하지 않은 노드를 모드 `Queue`에 삽입하고 방문 처리한다.
 - 2을 수행할 수 없을 떄까지 반복한다.

<br>


### 📋 BFS의 구현 예시

다음과 같이 간단한 미로를 찾을 때 사용한다.  
나는 주로 `BFS`를 사용하기 때문에 `BFS_Sample`이라는 코드를 미리 작성해두고 시간날때마다 보고 있다.  

```
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class BFS_sample {
    static class Pos {
        int r, c, dist;
        public Pos(int r, int c, int dist) {
            this.r = r;
            this.c = c;
            this.dist = dist;
        }
    }

    private static final int[] DR = {1, 0, -1, 0};
    private static final int[] DC = {0, 1, 0, -1};
    private static final char MAZE_START    = 'S';
    private static final char MAZE_BLOCK    = 'X';
    private static final char MAZE_END      = 'E';

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        final int R = Integer.parseInt(st.nextToken());
        final int C = Integer.parseInt(st.nextToken());

        Queue<Pos> q = new LinkedList<>();  // BFS를 위한 큐
        boolean[][] visited = new boolean[R][C];  // 이미 방문한 곳을 다시 가지 않도록 방문체크

        // 미로 입력 받기
        char[][] maze = new char[R][C];      // 미로맵을 받아둘 배열
        for (int i = 0; i < R; i++) {
            String curRow = br.readLine();
            for (int j = 0; j < C; j++) {
                char curCol = curRow.charAt(j);
                if (curCol == MAZE_START) {
                    q.add(new Pos(i, j, 0));    // 시작위치를 발견하면 바로 큐에 넣음
                    visited[i][j] = true; // 시작위치를 큐에 넣었으므로 방문한 것으 로 체크
                }
                maze[i][j] = curRow.charAt(j);
            }
        }

        // BFS 진행
        while (!q.isEmpty()) {
            Pos cur = q.poll(); // 큐에서 하나를 뽑아냄
            for (int i = 0; i < DR.length; i++) {   // 인접한 칸으로 탐색 진행
                int nextR = cur.r + DR[i];
                int nextC = cur.c + DC[i];
                int nextDist = cur.dist + 1;

                if (nextR < 0 || nextR >= R || nextC < 0 || nextC >= C || visited[nextR][nextC] || maze[nextR][nextC] == MAZE_BLOCK) {
                    continue; // 다음 탬색할 위치가 미로를 벗어난 위치이거나 이미 방문한 곳이거나 장애물인 경우 탐색에서 제외
                }

                if (maze[nextR][nextC] == MAZE_END) {   // 최종 목적지를 발견한 경우
                    System.out.println(nextDist);   // 거리를 출력하고,
                    return; // 그대로 종료하면 됨.
                }

                q.add(new Pos(nextR, nextC, nextDist)); // 큐에 다음 탐색할 곳을 넣음.
                visited[nextR][nextC] = true;   // 큐에 넣은 곳 방문체크
            }
        }

        System.out.println(-1); // 발견을 하지 못한 예외의 경우 -1을 출력.
    }
}
```

<br>

## 🔗 관련 예시


tag:DFS
tag:BFS


<br>


***
    개인 공부 기록용 블로그입니다.
    틀리거나 오류가 있을 경우 제보해주시면 감사하겠습니다.😁