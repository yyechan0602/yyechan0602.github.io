---
title:  "[ë°±ì¤€] ğŸ¥‡ 1938 í†µë‚˜ë¬´ ì˜®ê¸°ê¸°"
excerpt: "ì‹¤ë ¥í–¥ìƒì„ ìœ„í•œ ë°±ì¤€ ë¬¸ì œ ë° í’€ì´"

categories:
  - BaekJoon
tags:
  - ["1938", í†µë‚˜ë¬´ ì˜®ê¸°ê¸°, BFS, Java, Coding_Test, Coding, Test, baekJoon, ë°±ì¤€]

toc: true
toc_sticky: true
 
date: 2023-02-13
last_modified_at: 2023-02-14
---

## ğŸ“Œ ë‚œì´ë„

  ğŸ¥‡ Gold 2

<br>

## ğŸ“Œ ë¬¸ì œ

<https://www.acmicpc.net/problem/1938>

![image](https://user-images.githubusercontent.com/37824506/219363222-99ddd4f8-1b10-4c1c-803f-eacecd96031e.png)

![image](https://user-images.githubusercontent.com/37824506/219363321-7953be56-fb48-4920-a5bf-fffec0768c90.png)

![image](https://user-images.githubusercontent.com/37824506/219363374-f41193ed-31ac-40f7-9e8e-755125373c6b.png)





<br>

## ğŸ“Œ í’€ì´

ìµœê·¼ì— í‘¼ ê³¨ë“œ ë¬¸ì œì¤‘ì— ê°€ì¥ ë‚œì´ë„ê°€ ë†’ì€ ë¬´ë ¤ ê³¨ë“œ 2ì§œë¦¬ ë¬¸ì œì˜€ë‹¤.  
ì²˜ìŒ ë¬¸ì œë¥¼ ë³´ì ë“  ìƒê°ì€ `BFS` ë¡œ í’€ ë˜ í†µë‚˜ë¬´ ì¤‘ì‹¬ì„ ê¸°ì¤€ìœ¼ë¡œ ê°€ë¡œ, ì„¸ë¡œë¥¼ ë‚˜ëˆ ì„œ êµ¬í˜„í•˜ìëŠ” ìƒê°ì´ì˜€ë‹¤.  

ê·¸ë˜ì„œ í†µë‚˜ë¬´ë¥¼ ì €ì¥í•  `pos` ë¼ëŠ” ì´ë¦„ì˜ classë¥¼ ë§Œë“¤ê³ , ê·¸ ì•ˆì— `r`, `c`, `isVertical` ì´ë¼ëŠ” ë³€ìˆ˜ë“¤ì„ ë„£ì–´ì£¼ì—ˆë‹¤.  
ê·¸ë˜ê³  `field`ë¥¼ êµ¬ì„±í•  `tile`ì´ë¼ëŠ” ê°ì²´ì— `Vertical` ê°’ê³¼, `Horizontal` ê°’ì„ ì €ì¥í•  ë³€ìˆ˜ë¥¼ ë§Œë“¤ì–´ ì£¼ì—ˆë‹¤.  

ì¼ë°˜ì ì¸ `BFS` ì™€ ë‹¤ë¥´ê²Œ ì´ë™í•˜ëŠ” ì—¬ëŸ¬ê°€ì§€ ë°©í–¥ê³¼ í˜„ì¬ í†µë‚˜ë¬´ê°€ ì„¸ë¡œ, ê°€ë¡œì¸ì§€ì— ë”°ë¼ì„œ ì´ë™ ë°©ì‹ì´ ë‹¤ë¥´ë¯€ë¡œ `DR, DC` ë¥¼ ì œì™¸í•˜ê³ , ì—¬ëŸ¬ê°€ì§€ ë°©í–¥ ìƒìˆ˜ë°°ì—´ì„ ë§Œë“¤ì–´ì£¼ì—ˆë‹¤.  
ì´í›„ `BFS` ë¥¼ í†µí•´ êµ¬í˜„í•œ ì½”ë“œì´ë‹¤.

<br>

## ğŸ“Œ Code

```java
package BOJ.BFS;

import java.io.*;
import java.util.*;

public class N1938 {
    static class pos {
        int r;
        int c;
        boolean isVertical;

        public pos(int r, int c, boolean isVertical) {
            this.r = r;
            this.c = c;
            this.isVertical = isVertical;
        }
    }

    static class tile {
        int Vertical;
        int Horizontal;

        public tile(int state) {
            this.Vertical = state;
            this.Horizontal = state;
        }
    }

    static Queue<pos> q;
    static tile[][] field;
    static final int startPoint = 0;
    static final int notvisited = 1000002;
    static final int tree = -3;

    static final int[] VLDR = {-1, 0, 1};
    static final int[] VLDC = {-1, -1, -1};
    static final int[] VUDR = {-2};
    static final int[] VUDC = {0};

    static final int[] HLDR = {0};
    static final int[] HLDC = {-2};
    static final int[] HUDR = {-1, -1, -1};
    static final int[] HUDC = {-1, 0, 1};

    static final int[] ALLDR = {-1, -1, 0, 1, 1, 1, 0, -1};
    static final int[] ALLDC = {0, 1, 1, 1, 0, -1, -1, -1};
    static int N;

    static int flag;
    static final int CantGoGoal = 1000003;
    static boolean goalPoint;
    static int[] goalPointcoor;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());
        field = new tile[N][N];
        q = new LinkedList<>();
        boolean isVertical;
        int[][] start = new int[3][2];
        int[][] end = new int[3][2];
        int flag1 = 0;
        int flag2 = 0;
        for (int i = 0; i < N; i++) {
            String str = br.readLine();
            for (int j = 0; j < N; j++) {
                if (str.charAt(j) == '0') {
                    field[i][j] = new tile(notvisited);
                } else if (str.charAt(j) == '1') {
                    field[i][j] = new tile(tree);
                } else if (str.charAt(j) == 'B') {
                    start[flag1] = new int[]{i, j};
                    field[i][j] = new tile(notvisited);
                    flag1 += 1;
                } else {
                    end[flag2] = new int[]{i, j};
                    field[i][j] = new tile(notvisited);
                    flag2 += 1;
                }

            }
        }
        field[start[1][0]][start[1][1]] = new tile(startPoint);
        if (start[0][0] != start[2][0]) {
            q.add(new pos(start[1][0], start[1][1], true));
        } else {
            q.add(new pos(start[1][0], start[1][1], false));
        }
        goalPointcoor = new int[]{end[1][0], end[1][1]};
        if (end[0][0] != end[2][0]) {
            goalPoint = true;
        } else {
            goalPoint = false;
        }
        BFS();
    }

    static void BFS() {
        //ShowAll();
        flag = CantGoGoal;
        while (!q.isEmpty()) {
            pos cur = q.poll();
            if (cur.isVertical) {
                for (int i = 0; i < 5; i++) {
                    VerticalLog(cur, i);
                }
            } else {
                for (int i = 0; i < 5; i++) {
                    HorizonLog(cur, i);
                }
            }
            //ShowAll();
        }
        if (flag == CantGoGoal) {
            System.out.println(0);
        } else {
            System.out.println(flag);
        }
    }

    static void ShowAll() {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (i == goalPointcoor[0] && j == goalPointcoor[1]) {
                    System.out.print(">");
                } else {
                    System.out.print("|");
                }

                if (field[i][j].Horizontal == notvisited) {
                    System.out.printf("%2s.", "");
                } else {
                    System.out.printf("%3d", field[i][j].Horizontal);
                }

                if (field[i][j].Vertical == notvisited) {
                    System.out.printf("%2s.", "");
                } else {
                    System.out.printf("%3d", field[i][j].Vertical);
                }
            }
            System.out.println();
        }
        System.out.print("======================");
        System.out.println(flag);
    }

    static boolean VerticalLog(pos cur, int index) {
        switch (index) {
            case 0:
                // Vertical ì¢Œë¡œ ì´ë™
                for (int i = 0; i < VLDR.length; i++) {
                    int nextR = cur.r + VLDR[i];
                    int nextC = cur.c + VLDC[i];
                    if (nextR < 0 || nextR >= N || nextC < 0 || nextC >= N || field[nextR][nextC].Vertical == tree) {
                        return false;
                    }
                }
                if (cur.r == goalPointcoor[0] && cur.c - 1 == goalPointcoor[1] && goalPoint) {
                    flag = Math.min(flag, field[cur.r][cur.c].Vertical + 1);
                }
                if (field[cur.r][cur.c - 1].Vertical > field[cur.r][cur.c].Vertical + 1) {
                    field[cur.r][cur.c - 1].Vertical = field[cur.r][cur.c].Vertical + 1;
                    q.add(new pos(cur.r, cur.c - 1, true));
                }
                break;
            case 1:
                // Vertical ìš°ë¡œ ì´ë™
                for (int i = 0; i < VLDR.length; i++) {
                    int nextR = cur.r + VLDR[i];
                    int nextC = cur.c - VLDC[i];
                    if (nextR < 0 || nextR >= N || nextC < 0 || nextC >= N || field[nextR][nextC].Vertical == tree) {
                        return false;
                    }
                }
                if (cur.r == goalPointcoor[0] && cur.c + 1 == goalPointcoor[1] && goalPoint) {
                    flag = Math.min(flag, field[cur.r][cur.c].Vertical + 1);
                }
                if (field[cur.r][cur.c + 1].Vertical > field[cur.r][cur.c].Vertical + 1) {
                    field[cur.r][cur.c + 1].Vertical = field[cur.r][cur.c].Vertical + 1;
                    q.add(new pos(cur.r, cur.c + 1, true));
                }
                break;
            case 2:
                // Vertical ì•„ë˜ë¡œ ì´ë™
                for (int i = 0; i < VUDR.length; i++) {
                    int nextR = cur.r - VUDR[i];
                    int nextC = cur.c + VUDC[i];
                    if (nextR < 0 || nextR >= N || nextC < 0 || nextC >= N || field[nextR][nextC].Vertical == tree) {
                        return false;
                    }
                }
                if (cur.r + 1 == goalPointcoor[0] && cur.c == goalPointcoor[1] && goalPoint) {
                    flag = Math.min(flag, field[cur.r][cur.c].Vertical + 1);
                }
                if (field[cur.r + 1][cur.c].Vertical > field[cur.r][cur.c].Vertical + 1) {
                    field[cur.r + 1][cur.c].Vertical = field[cur.r][cur.c].Vertical + 1;
                    q.add(new pos(cur.r + 1, cur.c, true));
                }
                break;
            case 3:
                // ìœ„ë¡œ ì´ë™
                for (int i = 0; i < VUDR.length; i++) {
                    int nextR = cur.r + VUDR[i];
                    int nextC = cur.c + VUDC[i];
                    if (nextR < 0 || nextR >= N || nextC < 0 || nextC >= N || field[nextR][nextC].Vertical == tree) {
                        return false;
                    }
                }
                if (cur.r - 1 == goalPointcoor[0] && cur.c == goalPointcoor[1] && goalPoint) {
                    flag = Math.min(flag, field[cur.r][cur.c].Vertical + 1);
                }
                if (field[cur.r - 1][cur.c].Vertical > field[cur.r][cur.c].Vertical + 1) {
                    field[cur.r - 1][cur.c].Vertical = field[cur.r][cur.c].Vertical + 1;
                    q.add(new pos(cur.r - 1, cur.c, true));
                }
                break;
            case 4:
                // íšŒì „
                for (int i = 0; i < ALLDC.length; i++) {
                    int nextR = cur.r + ALLDR[i];
                    int nextC = cur.c + ALLDC[i];
                    if (nextR < 0 || nextR >= N || nextC < 0 || nextC >= N || field[nextR][nextC].Vertical == tree) {
                        return false;
                    }
                }
                if (cur.r == goalPointcoor[0] && cur.c == goalPointcoor[1] && !goalPoint) {
                    flag = Math.min(flag, field[cur.r][cur.c].Vertical + 1);
                }
                if (field[cur.r][cur.c].Horizontal > field[cur.r][cur.c].Vertical + 1) {
                    field[cur.r][cur.c].Horizontal = field[cur.r][cur.c].Vertical + 1;
                    q.add(new pos(cur.r, cur.c, false));
                }
        }
        return true;
    }

    static boolean HorizonLog(pos cur, int index) {
        switch (index) {
            case 0:
                // Vertical ì¢Œë¡œ ì´ë™
                for (int i = 0; i < HLDR.length; i++) {
                    int nextR = cur.r + HLDR[i];
                    int nextC = cur.c + HLDC[i];
                    if (nextR < 0 || nextR >= N || nextC < 0 || nextC >= N || field[nextR][nextC].Horizontal == tree) {
                        return false;
                    }
                }
                if (cur.r == goalPointcoor[0] && cur.c - 1 == goalPointcoor[1] && !goalPoint) {
                    flag = Math.min(flag, field[cur.r][cur.c].Horizontal + 1);
                }
                if (field[cur.r][cur.c - 1].Horizontal > field[cur.r][cur.c].Horizontal + 1) {
                    field[cur.r][cur.c - 1].Horizontal = field[cur.r][cur.c].Horizontal + 1;
                    q.add(new pos(cur.r, cur.c - 1, false));
                }
                break;
            case 1:
                // Vertical ìš°ë¡œ ì´ë™
                for (int i = 0; i < HLDR.length; i++) {
                    int nextR = cur.r + HLDR[i];
                    int nextC = cur.c - HLDC[i];
                    if (nextR < 0 || nextR >= N || nextC < 0 || nextC >= N || field[nextR][nextC].Horizontal == tree) {
                        return false;
                    }
                }
                if (cur.r == goalPointcoor[0] && cur.c + 1 == goalPointcoor[1] && !goalPoint) {
                    flag = Math.min(flag, field[cur.r][cur.c].Horizontal + 1);
                }
                if (field[cur.r][cur.c + 1].Horizontal > field[cur.r][cur.c].Horizontal + 1) {
                    field[cur.r][cur.c + 1].Horizontal = field[cur.r][cur.c].Horizontal + 1;
                    q.add(new pos(cur.r, cur.c + 1, false));
                }
                break;
            case 2:
                // Vertical ì•„ë˜ë¡œ ì´ë™
                for (int i = 0; i < HUDR.length; i++) {
                    int nextR = cur.r - HUDR[i];
                    int nextC = cur.c + HUDC[i];
                    if (nextR < 0 || nextR >= N || nextC < 0 || nextC >= N || field[nextR][nextC].Horizontal == tree) {
                        return false;
                    }
                }
                if (cur.r + 1 == goalPointcoor[0] && cur.c == goalPointcoor[1] && !goalPoint) {
                    flag = Math.min(flag, field[cur.r][cur.c].Horizontal + 1);
                }
                if (field[cur.r + 1][cur.c].Horizontal > field[cur.r][cur.c].Horizontal + 1) {
                    field[cur.r + 1][cur.c].Horizontal = field[cur.r][cur.c].Horizontal + 1;
                    q.add(new pos(cur.r + 1, cur.c, false));
                }
                break;
            case 3:
                // ìœ„ë¡œ ì´ë™
                for (int i = 0; i < HUDR.length; i++) {
                    int nextR = cur.r + HUDR[i];
                    int nextC = cur.c + HUDC[i];
                    if (nextR < 0 || nextR >= N || nextC < 0 || nextC >= N || field[nextR][nextC].Horizontal == tree) {
                        return false;
                    }
                }
                if (cur.r - 1 == goalPointcoor[0] && cur.c == goalPointcoor[1] && !goalPoint) {
                    flag = Math.min(flag, field[cur.r][cur.c].Horizontal + 1);
                }
                if (field[cur.r - 1][cur.c].Horizontal > field[cur.r][cur.c].Horizontal + 1) {
                    field[cur.r - 1][cur.c].Horizontal = field[cur.r][cur.c].Horizontal + 1;
                    q.add(new pos(cur.r - 1, cur.c, false));
                }
                break;
            case 4:
                // íšŒì „
                for (int i = 0; i < ALLDC.length; i++) {
                    int nextR = cur.r + ALLDR[i];
                    int nextC = cur.c + ALLDC[i];
                    if (nextR < 0 || nextR >= N || nextC < 0 || nextC >= N || field[nextR][nextC].Horizontal == tree) {
                        return false;
                    }
                }
                if (cur.r == goalPointcoor[0] && cur.c == goalPointcoor[1] && goalPoint) {
                    flag = Math.min(flag, field[cur.r][cur.c].Horizontal + 1);
                }
                if (field[cur.r][cur.c].Vertical > field[cur.r][cur.c].Horizontal + 1) {
                    field[cur.r][cur.c].Vertical = field[cur.r][cur.c].Horizontal + 1;
                    q.add(new pos(cur.r, cur.c, true));
                }
        }
        return true;
    }
}
```


package (ì´ë¦„); ë¥¼ ë•Œê³ , class ì´ë¦„ì„ `Main`ìœ¼ë¡œ ë³€ê²½í•˜ë©´ ëœë‹¤.
{: .notice} 

<br>

## ğŸ“Œ ì¶”ê°€ ì˜ˆì œ

```
[Input]
5
00011
BBB00
00011
00000
EEE00

[Output]
3
```

```
[Input]
7
0000000
0E00000
0E00BBB
0E01001
0000000
0000001
0100000

[Output]
5
```  

```
[Input]
7
0000000
0E00000
0E00BBB
0E01001
0000000
0000001
0100000

[Output]
5
```

<br>


***
    ê°œì¸ ê³µë¶€ ê¸°ë¡ìš© ë¸”ë¡œê·¸ì…ë‹ˆë‹¤.
    í‹€ë¦¬ê±°ë‚˜ ì˜¤ë¥˜ê°€ ìˆì„ ê²½ìš° ì œë³´í•´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤.ğŸ˜